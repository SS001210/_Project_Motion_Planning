import matplotlib.pyplot as plt
import numpy as np
from FrenetOptimalTrajectory.frenet_optimal_trajectory import frenet_optimal_planning, generate_target_course

# Define road dimensions and parameters for curvature
road_length = 150
road_width = 10  # Single lane width
curve_amplitude = 10
curve_frequency = 3

# Generate x coordinates along the road
x = np.linspace(0, road_length, 500)

# Define the single-lane road using a sine function for the y-coordinates
y_lane_center = curve_amplitude * np.sin(curve_frequency * np.pi * x / (road_length - 50))
y_lane_center[x >= road_length - 50] = 0  # Straight segment near the end

# Initial state of the blue car
blue_car_x = 5
blue_car_y = curve_amplitude * np.sin(curve_frequency * np.pi * blue_car_x / (road_length - 50))
blue_car_speed = 10.0 / 3.6  # Initial speed [m/s]
blue_car_yaw = 0.0  # Initial yaw angle [rad]

# Add a static obstacle (another car) in the path
static_obstacle_x = 10
static_obstacle_y = curve_amplitude * np.sin(curve_frequency * np.pi * static_obstacle_x / (road_length - 50))
obstacles = np.array([[static_obstacle_x, static_obstacle_y]])

# Generate the target course using the lane center
_, _, _, _, csp = generate_target_course(x, y_lane_center)

# Define initial Frenet state variables
s0 = 0.0  # Initial arc length on the road centerline
c_speed = blue_car_speed  # Initial speed [m/s]
c_accel = 0.0  # Initial acceleration [m/s^2]
c_d = 0.0  # Initial lateral offset from centerline [m]
c_d_d = 0.0  # Initial lateral speed [m/s]
c_d_dd = 0.0  # Initial lateral acceleration [m/s^2]

# Simulation parameters
SIM_LOOP = 500  # Number of simulation steps
area = 20.0  # Animation area length [m]

# Zebra crossing parameters
zebra_start_x = road_length - 30  # Start position of the zebra crossing
zebra_width = 5  # Width of the zebra crossing

# Pedestrian parameters
pedestrian_position = [zebra_start_x + zebra_width / 2, road_width / 2]  # Initial pedestrian position at the top of the zebra crossing
pedestrian_speed = 3  # Pedestrian speed [m/s]
pedestrian_detect_range = 25  # Detection range for car [m]
pedestrian_safe_distance = 5  # Safe distance for pedestrian [m]

pedestrian_active = False  # Pedestrian starts stationary

# Create a figure for animation
fig, ax = plt.subplots(figsize=(10, 5))

for i in range(SIM_LOOP):
    # Perform Frenet optimal planning
    path = frenet_optimal_planning(csp, s0, c_speed, c_accel, c_d, c_d_d, c_d_dd, obstacles)

    # Update the state based on the planned path
    s0 = path.s[1]
    c_d = path.d[1]
    c_d_d = path.d_d[1]
    c_d_dd = path.d_dd[1]
    c_speed = path.s_d[1]
    c_accel = path.s_dd[1]
    blue_car_yaw = path.yaw[1]

    # Check if the car reaches the end of the road
    if np.hypot(path.x[1] - x[-1], path.y[1] - y_lane_center[-1]) <= 1.0:
        print("Goal reached!")
        break

    # Calculate distance between car and pedestrian
    pedestrian_distance = np.hypot(pedestrian_position[0] - path.x[1], pedestrian_position[1] - path.y[1])

    # Activate pedestrian movement if car is in range
    if pedestrian_distance < pedestrian_detect_range:
        pedestrian_active = True

    # Move pedestrian downwards along the zebra crossing if active
    if pedestrian_active:
        pedestrian_position[1] -= pedestrian_speed * 0.1
        if pedestrian_position[1] < -road_width / 2:
            pedestrian_position[1] = -road_width / 2  # Stop at the bottom of the zebra crossing

    # Adjust car behavior based on pedestrian proximity
    if pedestrian_distance < pedestrian_detect_range:
        if pedestrian_distance < pedestrian_safe_distance:
            print("Emergency stop: Pedestrian too close!")
            c_speed = 0
        else:
            print("Slowing down for pedestrian.")
            c_speed = max(0, c_speed - 0.1)
    else:
        c_speed = min(blue_car_speed, c_speed + 0.1)  # Resume normal speed

    # Visualization
    ax.clear()
    # Draw the road boundaries
    y_top = y_lane_center + road_width / 2
    y_bottom = y_lane_center - road_width / 2
    ax.plot(x, y_top, color="black", linewidth=2)
    ax.plot(x, y_bottom, color="black", linewidth=2)

    # Plot the planned trajectory
    ax.plot(path.x, path.y, "-r", label="Planned Trajectory")

    # Draw the blue car as a rectangle with yaw
    car_length = 2  # Reduced size
    car_width = 1   # Reduced size
    car_rect = plt.Rectangle((path.x[1] - car_length / 2, path.y[1] - car_width / 2),
                              car_length, car_width, angle=np.rad2deg(blue_car_yaw),
                              color="blue", label="Blue Car")
    ax.add_patch(car_rect)

    # Draw the static obstacle (another car)
    obstacle_rect = plt.Rectangle((static_obstacle_x - car_length / 2, static_obstacle_y - car_width / 2),
                                   car_length, car_width, color="red", label="Static Obstacle")
    ax.add_patch(obstacle_rect)

    # Draw the zebra crossing as a black rectangle
    ax.add_patch(plt.Rectangle((zebra_start_x, -road_width / 2), zebra_width, road_width, color="black"))

    # Draw the pedestrian
    pedestrian_circle = plt.Circle((pedestrian_position[0], pedestrian_position[1]), 0.5, color="red", label="Pedestrian")
    ax.add_patch(pedestrian_circle)

    # Set limits and labels
    ax.set_xlim(path.x[1] - area, path.x[1] + area)
    ax.set_ylim(path.y[1] - area, path.y[1] + area)
    ax.set_aspect('equal', adjustable='box')
    ax.axis("off")
    ax.legend()
    plt.pause(0.001)

print("Simulation complete.")
plt.show()
