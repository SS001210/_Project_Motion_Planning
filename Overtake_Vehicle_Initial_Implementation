import matplotlib.pyplot as plt
import numpy as np
from FrenetOptimalTrajectory.frenet_optimal_trajectory import frenet_optimal_planning, generate_target_course

# Define road dimensions and parameters for curvature
road_length = 250
road_width = 15  # Single lane width
curve_amplitude = 10
curve_frequency = 3

# Generate x coordinates along the road
x = np.linspace(0, road_length, 500)

# Define the single-lane road using a sine function for the y-coordinates
y_lane_center = curve_amplitude * np.sin(curve_frequency * np.pi * x / road_length)

# Initial state of the blue car
blue_car_x = 5
blue_car_y = curve_amplitude * np.sin(curve_frequency * np.pi * blue_car_x / road_length)
blue_car_speed = 10.0 / 3.6  # Initial speed [m/s]
blue_car_yaw = 0.0  # Initial yaw angle [rad]

# Add a static obstacle (another car) in the path
static_obstacle_x = 50
static_obstacle_y = curve_amplitude * np.sin(curve_frequency * np.pi * static_obstacle_x / road_length)
obstacles = np.array([[static_obstacle_x, static_obstacle_y]])

# Generate the target course using the lane center
_, _, _, _, csp = generate_target_course(x, y_lane_center)

# Define initial Frenet state variables
s0 = 0.0  # Initial arc length on the road centerline
c_speed = blue_car_speed  # Initial speed [m/s]
c_accel = 0.0  # Initial acceleration [m/s^2]
c_d = 0.0  # Initial lateral offset from centerline [m]
c_d_d = 0.0  # Initial lateral speed [m/s]
c_d_dd = 0.0  # Initial lateral acceleration [m/s^2]

# Simulation parameters
SIM_LOOP = 500  # Number of simulation steps
area = 20.0  # Animation area length [m]

# Create a figure for animation
fig, ax = plt.subplots(figsize=(10, 5))

for i in range(SIM_LOOP):
    # Perform Frenet optimal planning
    path = frenet_optimal_planning(csp, s0, c_speed, c_accel, c_d, c_d_d, c_d_dd, obstacles)

    # Update the state based on the planned path
    s0 = path.s[1]
    c_d = path.d[1]
    c_d_d = path.d_d[1]
    c_d_dd = path.d_dd[1]
    c_speed = path.s_d[1]
    c_accel = path.s_dd[1]
    blue_car_yaw = path.yaw[1]

    # Check if the car reaches the end of the road
    if np.hypot(path.x[1] - x[-1], path.y[1] - y_lane_center[-1]) <= 1.0:
        print("Goal reached!")
        break

    # Visualization
    ax.clear()
    # Draw the road boundaries
    y_top = curve_amplitude * np.sin(curve_frequency * np.pi * x / road_length) + road_width / 2
    y_bottom = curve_amplitude * np.sin(curve_frequency * np.pi * x / road_length) - road_width / 2
    ax.plot(x, y_top, color="black", linewidth=2)
    ax.plot(x, y_bottom, color="black", linewidth=2)

    # Plot the planned trajectory
    ax.plot(path.x, path.y, "-r", label="Planned Trajectory")

    # Draw the blue car as a rectangle with yaw
    car_length = 4
    car_width = 2
    car_rect = plt.Rectangle((path.x[1] - car_length / 2, path.y[1] - car_width / 2),
                              car_length, car_width, angle=np.rad2deg(blue_car_yaw),
                              color="blue", label="Blue Car")
    ax.add_patch(car_rect)

    # Draw the static obstacle (another car)
    obstacle_rect = plt.Rectangle((static_obstacle_x - car_length / 2, static_obstacle_y - car_width / 2),
                                   car_length, car_width, color="red", label="Static Obstacle")
    ax.add_patch(obstacle_rect)

    # Set limits and labels
    ax.set_xlim(path.x[1] - area, path.x[1] + area)
    ax.set_ylim(path.y[1] - area, path.y[1] + area)
    ax.set_aspect('equal', adjustable='box')
    ax.axis("off")
    ax.legend()
    plt.pause(0.001)

print("Simulation complete.")
plt.show()
